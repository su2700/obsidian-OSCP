
**gobuster 没找到但 dirsearch 找到**，主要原因不是“工具坏了”，而是两者在**请求方式、目标（http vs https）、尝试的路径/编码、以及默认字典与探测策略**上不同。下面用中文把原因分条讲清，并给出能让 gobuster 也找到相同结果的具体命令和建议。

---

## 一、关键差异（为什么会出现不同结果）

1. **你针对的协议不同**
    
    - 你运行 `gobuster` 时用了 `http://192.168.120.245/`，而 `dirsearch` 的输出显示它是针对 `https://192.168.120.245/` 的。
        
    - 服务器对 HTTP 很多路径会做 **301 重定向到 HTTPS**，而某些路径（比如 `/cgi-bin/...`）在 HTTPS 端直接返回 200。dirsearch 直接访问 HTTPS，因此能看到这些资源；gobuster 访问 HTTP 时被重定向或服务器在 HTTP 上没暴露相同的行为。
        
2. **请求路径与编码策略不同**
    
    - dirsearch 在日志中显示的成功项包含像 `/cgi-bin/.%2e/%2e%2e/.../etc/passwd`、`/cgi-bin/test-cgi`、`/cgi-bin/printenv` 等。这些是**目录穿越编码（URL-encoded traversal）**和 CGI 脚本测试；并不是普通目录字典里的条目。
        
    - gobuster 用的 `raft-large-directories.txt` 是常规目录名列表，里面可能 **没有** 那些带 `%2e%2e`、`test-cgi`、`printenv` 之类的特定 payloads。因此 gobuster 没发出这些带编码或特殊路径的请求。
        
3. **工具默认行为与探测逻辑不同**
    
    - dirsearch 默认会尝试多种扩展、尝试 URL 编码、一些常见的 CGI 测试用例，以及在 HTTPS 上直接探测（并能自动处理重定向/证书）。
        
    - gobuster 的 `dir` 模式偏向“简单的字典+请求”，不会自动去做路径编码/穿越 payload 或特定 CGI 探测，除非字典里包含这些条目或你启用相应参数。
        
4. **状态码过滤与重定向处理**
    
    - gobuster 输出只显示 301 的几个目录（重定向到 /js/ /css/ 等），默认有一套包含/排除状态码的规则，可能没有把某些 200 的变体列出（或你的字典未触发这些路径）。
        
    - dirsearch 把 200/403/301 等多种状态码都记录下来，并且会显示 200 的 `/cgi-bin/...` 成功条目。

```
 curl -v -L -k --path-as-is "https://192.168.120.245/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
```

- `-v` 显示请求/响应头（可以看到是否有 `Location` 头）；
    
- `-L` 跟随重定向（看最终去哪了）；
    
- `-k` 跳过自签名证书验证（如果是 HTTPS）；
    
- `--path-as-is` 非常关键：阻止 curl 对路径做规范化，按你写的编码形式发送。

## 字符层面的解码

- `%2e` 是 URL 百分号编码（percent-encoding）里对 `.`（点号）的编码。
    
- 所以：
    
    - `.%2e` → `.` + `%2e` → `.` + `.` → `..`
        
    - `%2e%2e` → `.` `.` → `..`
        

把你的字符串按段解码：

`.%2e / %2e%2e / %2e%2e / %2e%2e / etc/passwd   ↓      ↓       ↓       ↓   .. /  .. /  .. /  .. / etc/passwd`

合起来就是等价于：

`../../../../etc/passwd`

也就是向上跳 4 层目录然后访问 `/etc/passwd`。
你的 payload：

`https://192.168.120.245/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd`

### 🧱 Chrome 的行为

浏览器在发送请求前，会自动做：

1. 把 `%2e` 解码成 `.`；
    
2. 然后把路径规范化：
    
    `/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd → /cgi-bin/../../../../etc/passwd → /etc/passwd   （向上跳了四层后规范化）`
    
3. Chrome 发现这个路径超出了网站根目录，于是：
    
    - 把它变成 `/etc/passwd` 并向服务器请求；
        
    - 或者直接拒绝请求、自动跳转（如果服务端返回 `Location:`）。
        

结果：**你的目录穿越载荷被“中和”了**，所以浏览器看起来“打不开”。

---

### 🧰 curl 的行为

默认情况下，curl 也会规范化路径；但当你加上

`--path-as-is`

它会强制按你写的样子发送请求。  
也就是说，curl 真的向服务器发出了：

`GET /cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd HTTP/1.1`

服务器端（Apache 2.4.49）在解析时存在漏洞：它在安全检查前先解码 `%2e` → `.`，  
于是实际访问的是：

`/cgi-bin/../../../../etc/passwd`

这就命中了漏洞（路径穿越），返回了 `/etc/passwd` 内容。

---

## 🔐 三、为什么浏览器要这样设计

Chrome、Firefox、Edge 等浏览器：

- 遵循 **RFC 3986**（URL 规范），规定 `%2e` 必须等价于 `.`，必须在发送前做规范化。
    
- 同时它们必须防止“**路径穿越攻击**”——不能允许网页脚本发出 `/../` 之类的请求，因为这会导致本地文件泄露或跨目录访问。
    
- 所以它们在内部强制做安全净化（canonicalization），**用户无法绕过**。
    

👉 简单说：**浏览器是“为安全设计的”，curl 是“为控制设计的”。**


![[Pasted image 20251030211439.png]]